<html>
<head>
<style>
#info {
  position: absolute;
  width:100%;
  text-align: center;
  color: #ffff00
}
</style>
</head>
<body>
<div id='info'>
  Up: fight; Down: squat
  <br>
  Left: move left; Right: move right
</div>


<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.136';

var camera, scene, renderer;
var bg, sprite;
var keyboard = new KeyboardState();
var direction = 1;
var move;

init();
animate();



function init() {
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.OrthographicCamera(-5, 5, 6, -6, -10, 1000);
  camera.position.z = 20;
  scene.add(camera);


  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  bg = loader.load('https://i.imgur.com/N7uwVuf.png');
  bg.wrapS = THREE.RepeatWrapping;


  let bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({
    map: bg
  }));
  scene.add(bgPlane);

  // load a resource
  loader.load(
    // resource URL
    'https://i.imgur.com/xroZA8g.png?1',
    // Function when resource is loaded
    function(texture) {
      // do something with the texture
      // Plane with default texture coordinates [0,1]x[0,1]

      sprite = new THREE.Mesh(buildGeometry(), new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,

      }));
      scene.add(sprite);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
    },
    undefined,
    // Function called when download errors
    function(xhr) {
      console.log('An error happened');
    }
  );

  //setInterval(textureAnimate, 100);
}

function animate() {
  keyboard.update();
  if (keyboard.pressed('up') || keyboard.pressed('down')) {
    setTimeout(() => textureAnimate(), 300);
    setTimeout(() => animate(), 300);
    textureAnimate.count++;
    textureAnimate();
    //console.log(textureAnimate.count);
  } else {
    setTimeout(() => textureAnimate(), 100);
    setTimeout(() => animate(), 100);

  }
  //requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function buildGeometry() {

  var geometry = new THREE.BufferGeometry();
  let vertices = [];
  let uvs = [];
  let indices = [0, 1, 2, 0, 2, 3];
  vertices.push(-1, -3, 0, 1, -3, 0, 1, 2, 0, -1, 2, 0);
  //uvs.push(0.02, 0.07, 0.1, 0.07, 0.1, 0.25, 0.02, 0.25);
  uvs.push(0, 0.82, 0.071, 0.82, 0.071, 1, 0, 1);

  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

  geometry.computeBoundingSphere();
  //geometry.computeFaceNormals();
  geometry.computeVertexNormals();
  return geometry;
}

function textureAnimate() {
  textureAnimate.count = (textureAnimate.count === undefined) ? 1 : textureAnimate.count;

  keyboard.update();

  if (sprite) {
    var movement = sprite.material.map;

    if (keyboard.pressed("up")) {
      movement.offset.y = 0.47;
      if (textureAnimate.count % 2 === 1) {
        if (direction === 1) {
          movement.offset.x = 0.08;
        } else {
          movement.offset.x = 0.42;
        }
      } else {
        movement.offset.x += 0.1;
      }
      //setTimeout((() => movement.offset.x += 0.1), 500);
      //textureAnimate.count++;
    } else if (keyboard.pressed("down")) {

      if (direction === 1) {
        movement.offset.y = 0.25;
        if (textureAnimate.count % 3 === 1)
          movement.offset.x = 0.02;
        else if (textureAnimate.count % 3 === 2)
          movement.offset.x = 0.13;
        else
          movement.offset.x = 0.23;
      } else {
        movement.offset.y = 0.27;
        if (textureAnimate.count % 3 === 1)
          movement.offset.x = 0.4;
        else if (textureAnimate.count % 3 === 2)
          movement.offset.x = 0.51;
        else
          movement.offset.x = 0.63;
      }

      //textureAnimate.count++;
    } else if (keyboard.pressed("left")) {
      textureAnimate.count++;

      direction = -1;
      if (sprite.position.x < -3) {
        bg.offset.x -= 0.04;
      } else {
        sprite.position.x -= 0.37;
      }

      movement.offset.y = -0.17;
      if (textureAnimate.count % 4 === 0) {
        movement.offset.x = 0.36;
      } else {
        movement.offset.x += 0.07;
      }
    } else if (keyboard.pressed("right")) {
      textureAnimate.count++;

      direction = 1;
      if (sprite.position.x > 3) {
        bg.offset.x += 0.04;
      } else {
        sprite.position.x += 0.37;
      }
      movement.offset.y = -0.167;
      if (textureAnimate.count % 4 === 0) {
        movement.offset.x = 0;
      } else {
        movement.offset.x += 0.07;
      }
      //console.log(movement.offset.x);
    } else {
      facing();
      textureAnimate.count = 0;
    }
    
  }
  //console.log(textureAnimate.count);
}

/*function down() {
  var movement = sprite.material.map;

  movement.offset.x += 0.205;

  down();

  setTimeout(facing, 500);
}

function up() {
  var movement = sprite.material.map;

  movement.offset.x += 0.1;

  setTimeout(facing, 500);

}

function moveRight(counting) {
  var movement = sprite.material.map;

  if (counting % 4 === 0) {
    movement.offset.x = 0;
  } else {
    movement.offset.x += 0.12;
  }
  counting++;
}
*/
function facing() {
  var movement = sprite.material.map;
  if (direction === 1) {
    movement.offset.x = 0;
    movement.offset.y = 0;
  } else {
    movement.offset.x = 0.35;
    movement.offset.y = 0;
  }
}

</script>
</body>
</html>